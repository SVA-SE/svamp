---
title: "DISEASE INVESTIGATION REPORT"
author: "Author    __SVA - ESS department__"
date: "Date of creation    __`r toupper(format(Sys.time(), '%B %d, %Y   %H:%M'))`__"
output:
  html_document:
    toc: true
    toc_depth: 4
    theme: cosmo
---

This report was requested by __`r paste(as.character(toupper(report_data_object()$firstname)), toupper(as.character(report_data_object()$lastname)), sep = " ")`__ to investigate the PPN n. __`r unique(as.character(report_data_object()$ppn))`__         


```{r Outbreak, warning = FALSE, message = FALSE, echo = FALSE, results = 'asis'}

farms_RT90 <- report_data_object()$result$farms_RT90
ppn <- report_data_object()$ppn

outbreak <- subset(farms_RT90, farms_RT90$Ppn == ppn)

```

<br>

### 1. GEOGRAPHIC LOCATION

* The PPN under investigation is located in __`r toupper(paste(outbreak@data$Lan))`__ within the municipality of __`r toupper(paste(outbreak@data$Kommun))`__ 

* The address of the PPN is __`r toupper(paste(outbreak@data$Adress,",", outbreak@data$Postnummer, "", outbreak@data$Kommun))`__


```{r PlotMap1, warning = FALSE, message = FALSE, echo = FALSE, results = 'asis', fig.height = 14, fig.width = 14}

NUTS_03M <- report_data_object()$NUTS_03M[
            report_data_object()$NUTS_03M$STAT_LEVL_ == 3, 1:2]
NUTS_03M@data$Lan <- report_data_object()$result$nuts_label$Swedish[
                       match(as.character(NUTS_03M@data$NUTS_ID),
                             report_data_object()$result$nuts_label$NUTS)]



# Check for points falling outside Swedish border

if(all(!is.na(over(outbreak, NUTS_03M)))) {
  
  lan <- over(outbreak,NUTS_03M)
  lan <- NUTS_03M[NUTS_03M@data$NUTS_ID == lan$NUTS_ID,]
  plot(NUTS_03M, axes = T)
  plot(lan, add = T, col = "yellow")


points(outbreak, pch = 19, col = "red", cex = 1)

# Add labels to the polygons

invisible(text(coordinates(NUTS_03M),
               labels = as.character(NUTS_03M@data$Lan), 
               cex = 0.8))

title(expression(paste("Geographic location of the PPN under investigation")))

legend("bottomright",
        cex = 1.3, 
        "PPN location", 
        pch = 19, 
        pt.cex = 1.2,
        col = "red",
        bty = "n")

} else {
   
  plot(1,1,col = "white")
  text(1,1,"Provided coordinates fall outside the Swedish borders")
}

```

The PPN is geolocated at the following coordinates:

```{r Coordinates, warning = FALSE, message = FALSE, echo = FALSE}

outbreak_WGS84 <- spTransform(outbreak, CRS("+init=epsg:4326"))
outbreak_SWEREF99 <- spTransform(outbreak_WGS84, CRS("+init=epsg:3006"))

df <- data.frame("RefSyst" = c("RT90", "WGS84", "SWEREF99"),
                 
                 "X" = c(as.integer(outbreak@coords[,1]),
                         outbreak_WGS84@coords[,1], 
                         outbreak_SWEREF99@coords[,1]),
                 
                 "Y" = c(as.integer(outbreak@coords[,2]),
                         outbreak_WGS84@coords[,2],
                         outbreak_SWEREF99@coords[,2]))

colnames(df) <- c("Reference system", "X coordinate", "Y coordinate")
                 
kable(df, digits=1, row.names = FALSE)   


```

****
<br>

```{r LeafletMap1, warning=FALSE, message=FALSE, echo = FALSE, fig.align='center',fig.width=8}

outbreak1 <- outbreak[ , c(1, 4, 8, 11, 41)]
outbreak1_wgs <- spTransform(outbreak1, CRS("+init=epsg:4326"))
pop_out <- paste(outbreak1_wgs@data)

LeafletMap1 <- leaflet(outbreak1_wgs) %>% addProviderTiles("CartoDB.Positron")

LeafletMap1 %>% addCircleMarkers(stroke = FALSE,
                                 fill = TRUE, 
                                 fillColor = "black",
                                 fillOpacity = 1,
                                 popup = pop_out)
```

****
<br>

### 2. NUMBER OF HERDS AND ANIMALS (for the investigated PPN)

```{r herds/anim_outbreak, results='asis', fig.height=4, fig.width=12, echo=FALSE}

PPN <- report_data_object()$result$PPN

outb.in.PPN <-  PPN[which(PPN$Ppn %in% outbreak@data$Ppn), ]

outb.in.PPN <- outb.in.PPN[!duplicated(outb.in.PPN [c("Ppn",
                                                      "Adress",
                                                      "Typ",
                                                      "Typ.1",
                                                      "tot_anim")]),]
counts <- table(outb.in.PPN$Typ)

# Draw the graph with herds/animals count for the outbreak

par(mfrow = c(1,2), mar=c(5.1, 4.8, 4.1, 2.1), 
    mgp=c(3.8, 1, 0), las=2)

width = ifelse(length(counts) == 1, 0.2, 0.8) #avoid big bar drawing when length=1

b1a <- barplot(counts,
               main = "Number of herds by species", 
               ylab = "Number of herds", 
               xlim = c(0, length(counts)),
               ylim = c(0, max(counts * 1.4)),
               width = width)

text(x = b1a, y = counts, label = counts, 
     pos = 3, cex = 0.8, col = "black")

if (all(is.na(outb.in.PPN$tot_anim))) {

    counts2 <- 0

    b1b <- barplot(counts2, 
               main = "Number of animals by species", 
               xaxt = "n", 
               xlab = "", 
               ylab = "", 
               col = "white", 
               border = NA, 
               sub =  "Number of animals is NA. See Excel file for details")

} else {

    outb.in.PPN <- outb.in.PPN [!is.na(outb.in.PPN$tot_anim),]

    counts2 <-tapply(outb.in.PPN$tot_anim, 
                     INDEX = outb.in.PPN$Typ, 
                     FUN = sum)
    
    width = ifelse(length(counts2) == 1, 0.2, 0.8)

    b1b <- barplot(counts2, 
               main = "Number of animals by species",
               ylab = "Number of animals", 
               ylim = c(0, max(counts2 * 1.4)),
               xlim = c(0, length(counts2)),
               width = width)

    text(x = b1b, y = counts2, label = counts2,
         pos = 3, cex = 0.8, col = "black")
}

```

****
<br>

### 3. OWNERS INFORMATION

```{r Match_Owners, results='asis', echo=FALSE}

index <- match(PPN$Ppn, outbreak@data$Ppn)
outbreak_own <- PPN[which(PPN$Ppn == outbreak@data$Ppn), ]
owners <- length(unique(outbreak_own$Namn))

```

The number of owners/reference persons for the PPN under investigation is: __`r owners`__

```{r OwnersData, results='asis', echo=FALSE}

colnames(outbreak_own)[c(33, 36, 37, 31)] <- c("Adress",
                                               "Postadress",
                                               "Telefonnummer",
                                               "Typ")

kable(unique(outbreak_own[,c(32, 33, 36, 37, 38, 39, 31)]),
      align = 'c', row.names = FALSE)

```

****
<br>

### 4. VETERINARY DISTRICTS INFORMATION

The 3 most closest veterinary districts (euclidean distance) from the investigated PPN position are: 

```{r VetDistrictDist, warning=FALSE, message=FALSE, echo = FALSE, results='asis'}

district_geo_RT90 <- report_data_object()$result$district_geo_RT90

# calculate euclidean distance from outbreak to vet disctrict
dist_vet <- spDistsN1(district_geo_RT90, outbreak, longlat = FALSE)/ 1000
dist_vet <- round(dist_vet, 3)
dist_vet <- cbind(district_geo_RT90@data[ , 2:6], dist_vet)
dist_vet <- dist_vet[order(dist_vet[, 6]), ]

# show only the three most closest
kable(head(dist_vet, 3), align = 'c', digits = 1, row.names = FALSE)

```


****

<br>

### 5. RESTRICTION ZONES

This section generates 3 circular restriction zones centered at the PPN's coordinates. If PPN coordinates were missing in the dataset, the circular buffers are centred on the provided coordinates. The zones have different radius: 

* 1 km (red zone)    
* 3 km (yellow zone)    
* 10 km (green zone)    

```{r Buffers, results = 'asis', echo = FALSE, warning = TRUE, message = TRUE}

#Buffers and Outbreak: Create multiple buffers
x <- coordinates(outbreak)[, 1] # Outbreak coord x
y <- coordinates(outbreak)[, 2] # Outbreak coord y

# So far working for 1 ppn per time
stopifnot(length(x) == 1 & length(y) == 1)

# Buffer. Draw a circle with 1 km radius
nr = 500 # n. of points
r = 1000 #input$buf1 # radius
buf1 = seq(0, 2 * pi, length.out = nr)
xy = cbind(x + r * sin(buf1), y + r * cos(buf1))

# Create the spatial object
buf_sp1 = SpatialPolygons(
  list(Polygons(
  list(Polygon(xy)), "1km")))
proj4string(buf_sp1) <- CRS("+init=epsg:3021")

#  Buffer. Draw a circle with 3 km radius
nr3 = 500 # n. of points
r3 = 3000 #input$buf2  # radius
buf3 = seq(0, 2 * pi, length.out = nr3)
xz = cbind(x + r3 * sin(buf3), y + r3 * cos(buf3))

# Create a "donut" insted of a buffer. 1 km is a hole in the 3 km buffer 
buf_sp3 = SpatialPolygons(
  list(Polygons(
  list(Polygon(xz, hole = F), Polygon(xy, hole = T)), "3km")))
proj4string(buf_sp3) <- CRS("+init=epsg:3021")

# Buffer. Draw a circle with 10 km radius
nr10 = 500 # n. of points
r10 = 10000 #input$buf3  # radius
buf10 = seq(0, (2 * pi), length.out = nr10)
yz = cbind(x + r10 * sin(buf10), y + r10 * cos(buf10))

# Create a "donut" insted of a buffer. 3km is a hole in the 10km buffer
buf_sp10 = SpatialPolygons(
          list(Polygons(
          list(Polygon(yz, hole = F), Polygon(xz, hole = T)), "10km" )))
proj4string(buf_sp10) <- CRS("+init=epsg:3021")

```


```{r FarmsInBuffers, results='asis', echo=FALSE}

# Spatial subset of farms in each buffer. When no farms inside buffers it gives back just the outbreak (to avoid an error in leafletR). Check if can be fixed using leaflet library

if(all(is.na(over(farms_RT90, buf_sp10)))) {
  
  farms_in10_RT90 <- outbreak1
  
} else {
  
  farms_in10_RT90 <- farms_RT90[buf_sp10, c(1,4,8,11,41)]
}

if(all(is.na(over(farms_RT90, buf_sp3)))) {
  
  farms_in3_RT90 <- outbreak1

} else {
  
  farms_in3_RT90 <- farms_RT90[buf_sp3, c(1,4,8,11,41)]
}

if(sum(!is.na(over(farms_RT90, buf_sp1))) == 0 |
   sum(!is.na(over(farms_RT90, buf_sp1))) == 1) {
  
  farms_in1_RT90 <- outbreak1
  
} else {
  
  farms_in1_RT90 <- farms_RT90[buf_sp1, c(1,4,8,11,41)]
  farms_in1_RT90 <- farms_in1_RT90[farms_in1_RT90@data$Ppn != ppn,]
}
```


```{r PlotMap2, fig.width=14, fig.height=14, echo=FALSE, warning=FALSE, message=FALSE}

plot(buf_sp10, axes = T, col = rgb(0,1,0, alpha = 0.3), lty=5, lwd = 2)
plot(buf_sp3, add = T, col = rgb(1,1,0, alpha = 0.3), lty=3, lwd = 2)
plot(buf_sp1, add = T, col = rgb(1,0,0, alpha = 0.3), lty = 2, lwd = 2)
plot(outbreak, add = T, col = "black", pch = 19, cex = 1)

if(!identical(farms_in10_RT90, outbreak1)) {
  if(nrow(farms_in10_RT90@data) == 1) {
    invisible(text(coordinates(farms_in10_RT90),
                   labels = as.character(farms_in10_RT90@data$Ppn),
                   cex = 0.6,
                   pos = 1,
                   offset = 1))
    
} else {
  
  textplot(coordinates(farms_in10_RT90)[, 1],
           coordinates(farms_in10_RT90)[, 2],
           as.character(farms_in10_RT90@data$Ppn),
           cex = 0.7,
           new = FALSE)
  
  plot(farms_in10_RT90, add = T, col = "green", bg = "black", pch = 19, cex = 0)
  
  }
}

if(!identical(farms_in3_RT90, outbreak1)) {
  if(nrow(farms_in3_RT90@data) == 1) {
   invisible(text(coordinates(farms_in3_RT90),
                  labels = as.character(farms_in3_RT90@data$Ppn),
                  cex = 0.7))
} else {
  
  textplot(coordinates(farms_in3_RT90)[, 1],
           coordinates(farms_in3_RT90)[, 2],
           as.character(farms_in3_RT90@data$Ppn),
           cex = 0.7,
           new = FALSE)

  plot(farms_in3_RT90, add = T, bg = "yellow", pch = 19, cex = 0)

  }
}


if(!identical(farms_in1_RT90, outbreak1)) {
  if(nrow(farms_in1_RT90@data) == 1) {
    invisible(text(coordinates(farms_in1_RT90),
                   labels = as.character(farms_in1_RT90@data$Ppn),
                   cex = 0.7))
} else {
  
  textplot(coordinates(farms_in1_RT90)[, 1],
           coordinates(farms_in1_RT90)[, 2],
           as.character(farms_in1_RT90@data$Ppn),
           cex = 0.7,
           new = FALSE)
  
  plot(farms_in1_RT90, add = T, bg = "red", pch = 19, cex = 0)

  }
}

legend("topright", cex = 1,
       c("Buffer 10 km", "Buffer 3 km", "Buffer 1 km"),
       pch = c(21, 21, 21), pt.cex = 0,
       fill = c("green", "yellow", "red"), bty = "n")

title(expression(paste("Restriction Zones: PPNs within buffer areas of 1, 3 and 10 km radius")))

```

****

<br>

```{r LeafletMap2, results='asis',echo=FALSE, warning=FALSE, message=FALSE, fig.width=9, fig.align='center'}

outbreak2 <- spTransform(outbreak1, CRS("+init=epsg:4326"))

# Buffer1km
buf_sp1_84 <- spTransform(buf_sp1, CRS("+init=epsg:4326"))
buf_spdf1_84 <- SpatialPolygonsDataFrame(buf_sp1_84,
                                       data.frame(N = "Restriction_zone_1km",
                                                  row.names = "1km"))

# Buffer3km
buf_sp3_84 <- spTransform(buf_sp3, CRS("+init=epsg:4326"))
buf_spdf3_84 <- SpatialPolygonsDataFrame(buf_sp3_84,
                                       data.frame(N="Restriction_zone_3km",
                                                  row.names="3km"))

# Buffer10km
buf_sp10_84 <- spTransform(buf_sp10, CRS("+init=epsg:4326"))
buf_spdf10_84 <- SpatialPolygonsDataFrame(buf_sp10_84,
                                       data.frame(N="Restriction_zone_10km",
                                                  row.names="10km"))


# farms within 1 km buffer
farms_in1_84 <- spTransform(farms_in1_RT90, 
                     CRS("+init=epsg:4326"))


# farms within 3 km buffer
farms_in3_84 <- spTransform(farms_in3_RT90, 
                     CRS("+init=epsg:4326"))


# farms within 10 km buffer
farms_in10_84 <- spTransform(farms_in10_RT90, 
                     CRS("+init=epsg:4326"))


# final map

pop_out <- paste0(outbreak2@data)

LeafletMap2 <- leaflet() %>% addProviderTiles("CartoDB.Positron")

LeafletMap2 %>%
  
  addCircleMarkers(data = farms_in10_84,
                   stroke = FALSE,
                   fill = TRUE,
                   fillColor = "green") %>%
  
  addCircleMarkers(data = farms_in3_84,
                   stroke = FALSE,
                   fill = TRUE,
                   fillColor = "yellow") %>%
  
  addCircleMarkers(data = farms_in1_84,
                   stroke = FALSE,
                   fill = TRUE,
                   fillColor = "red") %>%

  
  addPolygons(data = buf_spdf10_84, color = "green", fill = "green") %>%
  addPolygons(data = buf_spdf3_84, color = "yellow", fill = "yellow") %>%
  addPolygons(data = buf_spdf1_84, color = "red", fill = "red") %>%

  addCircleMarkers(data = outbreak2,
                   stroke = FALSE,
                   fill = TRUE,
                   fillColor = "black",
                   fillOpacity = 1,
                   popup = pop_out) 

```

****

<br>

### 6. SUMMARY STATISTICS FOR PPNs WITHIN RESTICTION ZONES

* There are __`r if(!identical(farms_in1_RT90,outbreak1)){sum(nrow(farms_in1_RT90@data))}else{"0"}`__ PPNs in 1 km radius from the position of the investigaed PPN 
<br>
* There are __`r if(!identical(farms_in3_RT90,outbreak1)){sum(nrow(farms_in3_RT90@data))}else{"0"}`__ PPNs in 3 km radius from the position of the investigaed PPN
<br>
* There are __`r if(!identical(farms_in10_RT90,outbreak1)){sum(nrow(farms_in10_RT90@data))}else{"0"}`__ PPNs in 10 km radius from the position of the investigaed PPN

<br>

```{r SumAnimal,results='asis',echo=FALSE}

#duplicated PPN records for total herds/farms/animal calculation

if(!identical(farms_in1_RT90, outbreak1)) {
  
  n.PPN.in1 <- PPN[which(PPN$Ppn %in% farms_in1_RT90@data$Ppn),]
}

if(!identical(farms_in3_RT90, outbreak1)) {
  
  n.PPN.in3 <- PPN[which(PPN$Ppn %in% farms_in3_RT90@data$Ppn),]
}

if(!identical(farms_in10_RT90, outbreak1)){
  
  n.PPN.in10 <- PPN[which(PPN$Ppn %in% farms_in10_RT90@data$Ppn),]
}


sum_anim <- function(n.PPN.in) {
  
  n.anim <- n.PPN.in[,c("Antal",
                        "Antalslaktplatser",
                        "Antalsuggplatser",
                        "CDB.Antal",
                        "Maxkapacitet")]
  
  ani_sum <- apply (n.anim, 1, FUN = sum, na.rm = T)
  
  n.PPN.in <- cbind (n.PPN.in, ani_sum)
  
return (n.PPN.in)

}

if(!identical(farms_in1_RT90, outbreak1)) {
  
  n.PPN.in1 <- sum_anim(n.PPN.in1)
  
}

if(!identical(farms_in3_RT90, outbreak1)) {
  
n.PPN.in3 <- sum_anim(n.PPN.in3)

}

if(!identical(farms_in10_RT90, outbreak1)) {
  
n.PPN.in10 <- sum_anim(n.PPN.in10)

}

# Exclusion of duplicated values when DjurhÃ¥llare== DJURINNEHAVARE (to sum properly)

if(!identical(farms_in1_RT90,outbreak1)) {
  
  n.PPN.in1 <- n.PPN.in1[!duplicated(n.PPN.in1[c("Ppn",
                                                 "Adress",
                                                 "Typ",
                                                 "Typ.1",
                                                 "tot_anim")]),]
}

if(!identical(farms_in3_RT90, outbreak1)) {
  
  n.PPN.in3 <- n.PPN.in3[!duplicated(n.PPN.in3[c("Ppn",
                                                 "Adress",
                                                 "Typ",
                                                 "Typ.1",
                                                 "tot_anim")]),]

}

if(!identical(farms_in10_RT90, outbreak1)) {
  
n.PPN.in10 <- n.PPN.in10[!duplicated(n.PPN.in10[c("Ppn",
                                                  "Adress",
                                                  "Typ",
                                                  "Typ.1",
                                                  "tot_anim")]),]
}

```

#### 6.1 SUMMARY STATISTICS FOR PPNs WITHIN 1 KM RADIUS

Total number of herds/animals per species belonging to PPNs inside the radius of __1km__ are showed in the graph: 

```{r herds/animIn1km, results='asis', fig.height=4, fig.width=12, echo=FALSE}

if(!identical(farms_in1_RT90, outbreak1)) {
      
      counts <- table(n.PPN.in1$Typ)
      
      counts2 <-tapply(n.PPN.in1$ani_sum, 
                       INDEX = n.PPN.in1$Typ,
                       FUN=sum)
      
      width = ifelse(length(counts) == 1, 0.2, 0.6)
      
      par(mfrow = c(1,2), las = 2)
      
      b1a <- barplot(counts,
                     main="Number of herds by species",
                     ylab = "Number of herds",
                     ylim = c(0, max(counts * 1.4)),
                     xlim = c(0, length(counts)),
                     width = width)
      
      text(x = b1a, y = counts, label = counts, 
           pos = 3, cex = 0.8, col = "black")
      
      b1b <- barplot(counts2,
                     main = "Number of animals by species",
                     ylab = "Number of animals",
                     ylim = c(0, max(counts2 * 1.4)),
                     xlim = c(0, length(counts2)),
                     width = width)
      
      text(x = b1b, y = counts2, label = counts2,
           pos = 3, cex = 0.8, col = "black")
      
} else {
      
     cat("* **No PPNs other than the investigated PPN within the  radius of 1 km**")
}
```

<br>

#### 6.2 SUMMARY STATISTICS FOR PPNs WITHIN 3 KM RADIUS

Total number of herds/animals per species belonging to PPNs inside the radius of __3km__ are showed in the graph:  

```{r herds/animIn3km,results='asis',fig.height=4, fig.width=12, echo=FALSE}

if(!identical(farms_in3_RT90, outbreak1)) {
      
      counts<- table(n.PPN.in3$Typ)
      
      counts2<-tapply(n.PPN.in3$ani_sum,
                      INDEX = n.PPN.in3$Typ,
                      FUN = sum)
      
      width = ifelse(length(counts) == 1, 0.2, 0.8)
      
      par(mfrow = c(1,2), mar = c(5.1, 4.8, 4.1, 2.1),
          mgp = c(3.8, 1, 0), las=2)
      
      b3a <- barplot(counts, 
                     main = "Number of herds by species",
                     ylab = "Number of herds",
                     ylim = c(0, max(counts * 1.4)),
                     xlim = c(0, length(counts)),
                     width = width)
      
      text(x = b3a, y = counts, label = counts, 
           pos = 3, cex = 0.8, col = "black",)
      
      b3b <- barplot(counts2,
                     main = "Number of animals by species",
                     ylab = "Number of animals",
                     ylim = c(0, max(counts2 * 1.4)),
                     xlim = c(0, length(counts2)),
                     width = width)
      
      text(x = b3b, y = counts2, label = counts2, 
           pos = 3, cex = 0.8, col = "black",)

} else {
      
     cat("* **No PPNs other than the investigated PPN within the radius of 3 km**")
}
```

<br>

#### 6.3 SUMMARY STATISTICS FOR PPNs WITHIN 10 KM RADIUS

Total number of herds/animals per species belonging to PPNs inside the radius of __10km__ are showed in the graph: 

```{r herds/animIn10km,results='asis',fig.height=4, fig.width=12, echo=FALSE}

if(!identical(farms_in10_RT90, outbreak1)) {
  
  counts <- table(n.PPN.in10$Typ)
  
  counts2 <- tapply(n.PPN.in10$ani_sum,
                        INDEX=n.PPN.in10$Typ,
                        FUN=sum)
  
  width = ifelse(length(counts) == 1, 0.2, 0.8)
  
  par(mfrow = c(1, 2), mar = c(5.1, 4.8, 4.1, 2.1),
      mgp = c(3.8, 1, 0), las = 2)
  
  b10a <- barplot(counts,
                  main = "Number of herds by species",
                  ylab = "Number of herds",
                  ylim = c(0, max(counts * 1.4)),
                  xlim = c(0, length(counts)),
                  width = width)
  
  text(x = b10a, y = counts, label = counts, 
           pos = 3, cex = 0.8, col = "black",)
  
  b10b <- barplot(counts2,
                  main = "Number of animals by species",
                  ylab = "Number of animals",
                  ylim = c(0, max(counts2 * 1.8)),
                  xlim = c(0, length(counts2)),
                  width = width)
  
  text(x = b10b, y = counts2, label = counts2, 
           pos = 3, cex = 0.8, col = "black",)

} else {
      
     cat("* **No PPNs other than the investigated PPN within the radius of 10 km**")
}
```

****

<br>

### 7. TYPE AND NUMBER OF ANIMALS

```{r PPNsDistance, results='asis', echo=FALSE}

if(!identical(farms_in1_RT90, outbreak1)) {
  
  dist_farms_in1_RT90 <- data.frame(farms_in1_RT90@data$Ppn,
                                    spDistsN1(farms_in1_RT90,
                                              outbreak,
                                              longlat = FALSE))
  
  colnames(dist_farms_in1_RT90) <- c("Ppn", "distance")
} 

if(!identical(farms_in3_RT90, outbreak1)) {

  dist_farms_in3_RT90 <- data.frame(farms_in3_RT90@data$Ppn,
                                    spDistsN1(farms_in3_RT90,
                                              outbreak,
                                              longlat = FALSE))
  
  colnames(dist_farms_in3_RT90) <- c("Ppn", "distance")
} 

if(!identical(farms_in10_RT90, outbreak1)) {
  
  dist_farms_in10_RT90 <- data.frame(farms_in10_RT90@data$Ppn,
                                     spDistsN1(farms_in10_RT90,
                                               outbreak,
                                               longlat = FALSE))
  
  colnames(dist_farms_in10_RT90)<-c("Ppn","distance")
}
```

This section reports the number of animals per each PPN included within  1, 3, 10 km radius. PPNs are displayed in ascending order by distance from the investigated PPN location.     
Some PPNs showed repeated records, due to dupliceted entries in "Typ.2" field distinguishing "DJURHALLARE" and "DJURINNEHAVARE". Such records are not shown in the following tables. However, the comprehensive list of PPN's records is available clicking the link to the excel files present at the bottom of each table.

<br>

#### 7.1 PPNs WHITHIN 1 KM RADIUS

<br>

```{r Anim1kmTable, echo=FALSE, results='asis', warning=FALSE, message=FALSE}

if(!identical(farms_in1_RT90, outbreak1)) {
  anim1 <- merge(dist_farms_in1_RT90, n.PPN.in1, by = "Ppn")
  anim1 <- anim1[order(anim1$distance, anim1$Typ), ]
  colnames(anim1)[2] <- "distans(m)"
  
# Table
anim1_DT <- anim1[, c(1,2,11,14,19,26,43)]
  
datatable(anim1_DT,
          options = list(
            columnDefs = list(
              list(className = 'dt-center',
                   targets = c(0,1,4,5,6))
              )
            )
          )  %>% formatRound('distans(m)', 0)

} else {
  
  cat("* **No PPNs other than the investigated PPN within the radius of 1km**")

}

```


<br>

#### 7.2 PPNs WHITHIN 3 KM RADIUS

<br>

```{r Anim3kmTable, results='asis', echo=FALSE}

if(!identical(farms_in3_RT90, outbreak1)){
  anim3 <- merge(dist_farms_in3_RT90, n.PPN.in3, by = "Ppn")
  anim3 <- anim3[order(anim3$distance, anim3$Typ), ]
  colnames(anim3)[2] <- "distans(m)"

# Table
  anim3_DT <- anim3[, c(1,2,11,14,19,26,43)]
  datatable(anim3_DT,
            options = list(
              columnDefs = list(
                list(className = 'dt-center',
                     targets = c(0,1,4,5,6))
                )
              )
            ) %>% formatRound('distans(m)', 0)

} else {
  
  cat("* **No PPNs other than the investigated PPN within the radius of 3 km**")

}
```


<br>

#### 7.3 PPNs WHITHIN 10 KM RADIUS

<br>

```{r Anim10kmTable, results='asis', echo=FALSE}

if(!identical(farms_in10_RT90, outbreak1)){
  anim10 <- merge(dist_farms_in10_RT90, n.PPN.in10, by = "Ppn")
  anim10 <- anim10[order(anim10$distance, anim10$Typ), ]
  colnames(anim10)[2] <- "distans(m)"
  
  # Table
  anim10_DT <- anim10[, c(1,2,11,14,19,26,43)]
  datatable(anim10_DT,
            options = list(
              columnDefs = list(
                list(className = 'dt-center',
                     targets = c(0,1,4,5,6))
                )
              )
            ) %>% formatRound('distans(m)', 0)

} else {
  
  cat("* **No PPNs other than the investigated PPN within the radius of 10 km**")

}
```


<br>

***

### 8. ANALYSIS OF CONTACTS (EpiContactTrace)

The analysis covers the last __90__ days from the date of report generation (__`r Sys.Date()`__).   
The most recent movements reported into the database are from __`r unique(max(report_data_object()$result$ani_move$t))`__.    

<br>

OBS! Animal movement data may be reported to Jordbruksverket as late as 7 days after a movement has occured


```{r EpicontacTrace, results='html',warning=FALSE, message=FALSE, comment=NA,echo=FALSE}

transfers <- report_data_object()$result$ani_move
outbreak <- outbreak@data$Ppn

# Perform contact tracing

contactTrace <- Trace(movements = report_data_object()$result$ani_move,
                      root = outbreak,
                      tEnd = Sys.Date(),
                      days = 90)

show(contactTrace)

```

<br>

***

### 9 MISSING COORDINATES

```{r Missing,results='asis', warning=FALSE, message=FALSE, echo = FALSE}

postnum_miss <- report_data_object()$result$postnum_miss

# FIX ASSIGNPROJ IN SVDC
proj4string(postnum_miss) <- CRS("+init=epsg:3021")

PPN_na <- report_data_object()$result$PPN_na

if (!all(is.na(over(postnum_miss, buf_sp1)))) {
  
  intersec1km <- postnum_miss[buf_sp1, ]
 
  # match postnummer with postnummer of PPN is.na
    PPN_pro1km <- PPN_na[PPN_na$Postnummer %in% 
                          intersec1km@data$POSTALCODE, ]
}

if (!all(is.na(over(postnum_miss, buf_sp3)))) {
  
  intersec3km <- postnum_miss[buf_sp3, ]
  
  PPN_pro3km <- PPN_na[PPN_na$Postnummer %in% 
                          intersec3km@data$POSTALCODE, ]
}

if (!all(is.na(over(postnum_miss, buf_sp10)))) {
  
  intersec10km <- postnum_miss[buf_sp10, ]
  
  PPN_pro10km <- PPN_na[PPN_na$Postnummer %in% 
                          intersec10km@data$POSTALCODE, ]
   
}

```

Only zip-codes (Postnummer) including PPNs with missing coordinates are displayed in the figure. White colored postnummers, when present, only include PPNs without missing coordinates, that were thus *a priori* excluded from the analysis.        
Note that generally the total number of PPNs for 10 km radius comprises PPNs already reported for 3 km and 1 km radius. PPNs lists for 3 km comprises PPNs already reported for 1 km radius.

* There are __`r if(exists("PPN_pro1km")){length(unique(PPN_pro1km$Ppn))}else{"0"}`__ PPNs within postnummers intersecting the buffer of __1 km__ radius     
* There are __`r if(exists("PPN_pro3km")){length(unique(PPN_pro3km$Ppn))}else{"0"}`__ PPNs within postnummers intersecting the buffer of __3 km__  radius     
* There are __`r if(exists("PPN_pro10km")){length(unique(PPN_pro10km$Ppn))}else{"0"}`__ PPNs within the postnummers intersecting the buffer of __10 km__  radius


```{r PlotMissing, fig.width=12, fig.height=10, echo=FALSE, warning=FALSE, message=FALSE}

postnum_not_miss <- report_data_object()$result$postnum_not_miss

# FIX ASSIGNPROJ IN SVDC
proj4string(postnum_not_miss) <- CRS("+init=epsg:3021")

if(exists("PPN_pro10km")){
  plot(intersec10km, col = "green")
  invisible(text(coordinates(intersec10km),
               labels=as.character(intersec10km@data$POSTALCODE), 
               cex = 0.8))
  }else{
  intersec10km_NM <- postnum_not_miss[buf_sp10,]
  plot(intersec10km_NM)
}

if(exists("PPN_pro3km")){
  plot(intersec3km, col = "yellow", add = TRUE)
  invisible(text(coordinates(intersec3km),
               labels = as.character(intersec3km@data$POSTALCODE), 
               cex = 0.8))
  }

if(exists("PPN_pro1km")){
  plot(intersec1km, col = "red", add = TRUE)
  invisible(text(coordinates(intersec1km),
               labels=as.character(intersec1km@data$POSTALCODE), 
               cex = 0.8))
  }

# plotting postnummer that have no missing coords (makes layout nicer)
# data(postnummer) is very heavy to plot..

plot(buf_sp10, add = TRUE, lty = 5, lwd = 2)
plot(buf_sp3, add = TRUE, lty = 3, lwd = 2)
plot(buf_sp1, add = TRUE, lty = 2, lwd = 2)

if (!all(is.na(over(postnum_not_miss, buf_sp10)))){
intersec10km_NM <- postnum_not_miss[buf_sp10, ]
plot(intersec10km_NM, add = TRUE) 
}

if (!all(is.na(over(postnum_not_miss, buf_sp3)))){
intersec3km_NM <- postnum_not_miss[buf_sp3, ]
plot(intersec3km_NM, add = TRUE)
}

if (!all(is.na(over(postnum_not_miss, buf_sp1)))){
intersec1km_NM <- postnum_not_miss[buf_sp1, ]
plot(intersec1km_NM, add = TRUE)
}

#plot(postnummer, add=TRUE)
title(expression(paste(" Postnummers intersecting buffer areas of 1, 3 and 10 km radius")))
```

<br>

#### 9.1 PPNs WHITHIN POSTNUMMERS INTERSECTING 1 KM BUFFER

```{r Missing table1, results='asis', warning=FALSE, message=FALSE, echo = FALSE}

if(exists("PPN_pro1km")) {

  ppn_post1 <- unique(PPN_pro1km[c("Postnummer", "Ppn", "Species")])
  ppn_post1_len <- as.data.frame(table(ppn_post1$Postnummer))
  ppn_post1 <- split(ppn_post1$Ppn, ppn_post1$Postnummer)
  
  ppn_post1 <- unlist(lapply(ppn_post1, function(x) {
    paste(x, collapse = ", ")
    }))
  
  ppn_post1 <- data.frame(cbind(labels(ppn_post1), ppn_post1),
                          ppn_post1_len[, 2])
  
  colnames(ppn_post1) <- c("Postnummer", "PPN (list)", "PPNs (n.)")
  
  kable(ppn_post1, row.names = FALSE)

} else {
  
  cat("* **Zip-codes intersecting the buffer of 1 km have no PPNs without missing coordinates**   ")

}

```
<br>

#### 9.2 PPNs WHITHIN POSTNUMMERS INTERSECTING 3 KM BUFFER

```{r Missing table3, results='asis', warning=FALSE, message=FALSE, echo = FALSE}

if(exists("PPN_pro3km")) {
  ppn_post3 <- unique(PPN_pro3km[c("Postnummer", "Ppn", "Species")])
  ppn_post3_len <- as.data.frame(table(ppn_post3$Postnummer))
  ppn_post3 <- split(ppn_post3$Ppn, ppn_post3$Postnummer)
  
  ppn_post3 <- unlist(lapply(ppn_post3, function(x) {
      paste(x, collapse=", ")
    }))
  
  ppn_post3 <- data.frame(cbind(labels(ppn_post3), ppn_post3),
                          ppn_post3_len[,2] )
  
  colnames(ppn_post3) <- c("Postnummer", "PPN (list)", "PPNs (n.)")
  
  kable(ppn_post3, row.names=FALSE) 

} else {
  
  cat("* **Zip-codes intersecting the buffer of 3 km have no PPNs without missing coordinates**   ")
  
}

```
<br>


#### 9.3 PPNs WHITHIN POSTNUMMERS INTERSECTING 10 KM BUFFER

```{r Missing table10, results='asis', warning=FALSE, message=FALSE, echo = FALSE}

if(exists("PPN_pro10km")) {
  
  ppn_post10 <- unique(PPN_pro10km[c("Postnummer", "Ppn", "Species")])
  ppn_post10_len <- as.data.frame(table(ppn_post10$Postnummer))
  ppn_post10 <- split(ppn_post10$Ppn, ppn_post10$Postnummer)
  
  ppn_post10 <- unlist(lapply(ppn_post10, function(x) {
    paste(x, collapse=", ")
    }))
  
  ppn_post10 <- data.frame(cbind(labels(ppn_post10), ppn_post10),
                           ppn_post10_len[, 2] )
  
  colnames(ppn_post10) <- c("Postnummer", "PPN (list)", "PPNs (n.)")
  
  kable(ppn_post10, row.names = FALSE)

} else {
  
  cat("* **Zip-codes intersecting the buffer of 10 km have no PPNs without missing coordinates**   ")
  
}

```
<br>

### 10. SYNDROMIC SURVEILLANCE DATA (SVASSS)

Data reported in the following tables are extracted from SVASSS's alarms datasets. In details, information were derived from:

 1. dataset of clinical data of vet visit to farms;
 2. dataset of lab samples submitted to SVA;
 3. dataset of animal movements (CDB)

<br>

#### 10.1. SVASSSS DATASET OF CLINICAL RECORDS

Information reported in the table were obtained by matching PPNs lying inside 10 km radius (or within the postnummers if PPN coordinates were missing) with PPNs present in the dataset of clinical records. Data are ordered first by Syndrome then by PPN

<br>

```{r SVASSS CLINICAL, echo=FALSE, results='asis'}

SVASSS.SJV.alarms.data <- report_data_object()$result$SVASSS.SJV.alarms.data

if(exists("PPN_pro1km")) {
  
    PPN_pro1km_2 <- PPN_pro1km["Ppn"]
    
} else {
  
    PPN_pro1km_2 <- data.frame(Ppn = outbreak1@data$Ppn)    
}

if(exists("PPN_pro3km")) {
  
  PPN_pro3km_2 <- PPN_pro3km["Ppn"]
    
} else {
    
  PPN_pro3km_2 <-  data.frame(Ppn=outbreak1@data$Ppn)
}

if(exists("PPN_pro10km")) {
  
  PPN_pro10km_2 <- PPN_pro10km["Ppn"]

} else {
  
  PPN_pro10km_2 <- data.frame(Ppn=outbreak1@data$Ppn)
}

merge_farm <- data.frame(Ppn = c(farms_in10_RT90@data$Ppn,
                                 farms_in3_RT90@data$Ppn,
                                 farms_in1_RT90@data$Ppn,
                                 outbreak1@data$Ppn))

merge_pro <- data.frame(Ppn = c(PPN_pro1km_2[, 1],
                                PPN_pro3km_2[, 1],
                                PPN_pro10km_2[, 1]))

alla <- unique(rbind(merge_farm, merge_pro))

id_SVASSS.SJV <- (SVASSS.SJV.alarms.data$PPN %in% alla$Ppn)
SVASSS.SJV <- SVASSS.SJV.alarms.data[id_SVASSS.SJV, ]

SVASSS.SJV2 <- SVASSS.SJV[, c(1,3,4,8,18)]
SVASSS.SJV2 <- unique(SVASSS.SJV2)
SVASSS.SJV2 <- SVASSS.SJV2[order(SVASSS.SJV2[, 5], 
                                 SVASSS.SJV2[, 3],
                                 SVASSS.SJV2[, 1]),]

if(nrow(SVASSS.SJV2) != 0) {
  
  colnames(SVASSS.SJV2) <- c("Datum",
                             "Distriktnamn",
                             "PPN",
                             "Djurslag",
                             "Syndrome")

  datatable(SVASSS.SJV2,
           options = list(
                    columnDefs = list(
                                    list(className = 'dt-center',
                                         targets = c(0,2,3,4)))
           ))
 
} else {
  
  cat("* **No SVASSS clinical data are present for the considered PPNs and time frame**" )

}

```

<br>

#### 10.2. SVASSS DATASET OF LAB SAMPLES

Information reported in the table were obtained by matching PPNs lying inside 10 km radius (or within the postnummers if PPN coordinates were missing) with PPNs present in the SVASSS dataset of lab sample records. Information about samples not related to a PPN (e.g. environmental samples) were also considered when coordinates were present.    

<br>

```{r  SVASSS LAB, warning=FALSE, message=FALSE, echo = FALSE, results='asis', fig.height=14, fig.width=14}

SVASSS.alarms.data <- report_data_object()$result$SVASSS.alarms.data

colnames(SVASSS.alarms.data)[26] <- "Y"
colnames(SVASSS.alarms.data)[27] <- "X"

# Yes coords, No PPN
lab_XY<-SVASSS.alarms.data[!is.na(SVASSS.alarms.data$X) |
                           !is.na(SVASSS.alarms.data$Y) &
                            is.na(SVASSS.alarms.data$PPN_original),]

coordinates(lab_XY) = cbind(lab_XY$X, lab_XY$Y)
proj4string(lab_XY) <- CRS("+init=epsg:3021")

#only coordinates inside Swedish borders
lab_XY_match <- lab_XY[NUTS_03M,]

#only coordinates outside Swedish borders
lab_XY_nomatch <- lab_XY[!complete.cases(over(lab_XY,NUTS_03M)),]

# For coordinates switching
# bbox <- lab_XY@bbox
# bbox <- Polygon(bbox)
# bbox = Polygons(list(bbox), "bbox")
# bbox = SpatialPolygons(list(bbox))
#                       
# if(any(over(lab_XY, bbox))){
#   YX_coords <- lab_XY[bbox,]
#   lab_XY<-lab_XY[lab_XY@data$Ppn %in% YX_coords@data$Ppn]
# }

# writeOGR(lab_XY, dsn="C:/project/Garbage",layer="lab_XY",driver="ESRI Shapefile",overwrite=T)

# No coords, No PPN
lab_no_XY_PPN<-SVASSS.alarms.data[is.na(SVASSS.alarms.data$X) &
                                  is.na(SVASSS.alarms.data$Y) &
                                  is.na(SVASSS.alarms.data$PPN_original),]

# Those are additional datasets lets see if they are useful later
# # No coords, Yes PPN 
# lab_PPN<-SVASSS.alarms.data[!is.na(SVASSS.alarms.data$PPN_original) &
#                              is.na(SVASSS.alarms.data$X) &
#                              is.na(SVASSS.alarms.data$Y),]
# 
# # Yes coords, Yes PPN
# lab_XY_PPN<-SVASSS.alarms.data[!is.na(SVASSS.alarms.data$X) &
#                            !is.na(SVASSS.alarms.data$Y) &
#                             !is.na(SVASSS.alarms.data$PPN_original),]

#  Yes PPN with and without coords
lab_PPN_only <- SVASSS.alarms.data[!is.na(SVASSS.alarms.data$PPN_original), ]

# index PPN in alla (that comprises all PPNs within the buffer or, for those PPNs without coordinates, intersecting postnummers)
labPPN_alla_i <- lab_PPN_only$PPN %in% alla$PPN

# Uppdrag with PPNs matching PPNs inside the buffers or PPNs (with missing coordinates) into the postnummers intersecting the buffers

lab_PPN_only <- lab_PPN_only [labPPN_alla_i, ]

# Uppdrag without PPN information intersecting the buffers

all_buffers <- spRbind(buf_sp1,buf_sp3)
all_buffers <- spRbind(all_buffers, buf_sp10)

if(any(!is.na(over(lab_XY_match, all_buffers)))) {
  
  lab_XY_match_buf1 <- lab_XY_match[all_buffers, ] 
}

if(exists("lab_XY_match_buf1")) {
  
  SVASSS.lab2 <- rbind(lab_XY_match_buf1@data, lab_PPN_only)

} else {
  
  SVASSS.lab2 <- lab_PPN_only
}

if(nrow(SVASSS.lab2) != 0) {

  SVASSS.lab2 <- SVASSS.lab2[, c(1,3,4,5,9)]
  SVASSS.lab2 <- unique(SVASSS.lab2)
  
  colnames(SVASSS.lab2) <- c("Uppdrag",
                             "Syndromic",
                             "Djurslag", 
                             "Species", 
                             "PPN")
  
  datatable(SVASSS.lab2,
           options = list(
                    columnDefs = list(
                                    list(className = 'dt-center',
                                         targets = c(0,1,2,3,4)))
           ))
} else {
  
  cat("* **No SVASSS lab samples are present for the considered PPNs and time frame**" )
       
}
```

<br>

#### 10.3. MISSING/INCORRECT INFORMATION     
There are __`r length(unique(lab_no_XY_PPN$UPPDRAG))`__ Uppdrag with missing coordinates and without any additional spatial information coming for the dataset lab samples     

There are __`r length(unique(lab_XY_nomatch$UPPDRAG))`__ Uppdrag with coordinates located outside the Swedish borders. Possibly X and Y coordinates are switched in the original dataset.

<br>

### 11. URAX DATA

<br>

```{r  URAX, warning=FALSE, message=FALSE, echo = FALSE, results='asis', eval=TRUE}


id_urax <- (urax$PPN %in% alla$Ppn)
urax_match <- urax[id_urax, ]

if(nrow(urax_match) != 0) {
  
  urax_match <- urax_match[, c(4,1,2,3,9,5)]
  urax_match <- unique(urax_match)
  colnames(urax_match) = c("PPN",
                           "\304RENDEID", 
                           "DATUM", 
                           "STATUS", 
                           "AGENS",
                           "ADRESS")
  datatable(urax_match,
           options = list(
                    columnDefs = list(
                                    list(className = 'dt-center',
                                         targets = c(0,1,2,3,4,5)))
            ))
     
} else {
  
  cat("* **No URAX data within considered spatial radius and time frame**" )

}

```

