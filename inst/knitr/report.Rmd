This report was requested by __`r paste(as.character(toupper(report_data_object()$firstname)), toupper(as.character(report_data_object()$lastname)), sep = " ")`__ to investigate the PPN n. __`r unique(as.character(report_data_object()$ppn))`__         


```{r Outbreak, warning = FALSE, message = FALSE, echo = FALSE, results = 'asis'}

farms_RT90 <- report_data_object()$result$farms_RT90
ppn <- report_data_object()$ppn

outbreak <- subset(farms_RT90, farms_RT90$Ppn == ppn)

```

<br>

### 1. GEOGRAPHIC LOCATION

* The PPN under investigation is located in __`r toupper(paste(outbreak@data$Lan))`__ within the municipality of __`r toupper(paste(outbreak@data$Kommun))`__ 

* The address of the PPN is __`r toupper(paste(outbreak@data$Adress,",", outbreak@data$Postnummer, "", outbreak@data$Kommun))`__


```{r PlotMap1, warning = FALSE, message = FALSE, echo = FALSE, results = 'asis', fig.height = 14, fig.width = 14}

NUTS_03M <- report_data_object()$NUTS_03M[
            report_data_object()$NUTS_03M$STAT_LEVL_ == 3, 1:2]
NUTS_03M@data$Lan <- report_data_object()$result$nuts_label$Swedish[
                       match(as.character(NUTS_03M@data$NUTS_ID),
                             report_data_object()$result$nuts_label$NUTS)]


plot(NUTS_03M, axes = T)

# Check for points falling outside Swedish border

if(all(!is.na(over(outbreak, NUTS_03M)))) {
  
  lan <- over(outbreak,NUTS_03M)
  lan <- NUTS_03M[NUTS_03M@data$NUTS_ID == lan$NUTS_ID,]
  plot(lan, add = T, col = "yellow")

}else{
   
  plot(1,1,col="white")
  text(1,1,"Provided coordinates fall outside the Swedish borders")
}

points(outbreak, pch = 19, col = "red", cex = 1)

# Add labels to the polygons

invisible(text(coordinates(NUTS_03M),
               labels = as.character(NUTS_03M@data$Lan), 
               cex = 0.8))

title(expression(paste("Geographic location of the PPN under investigation")))

legend("bottomright",
        cex = 1.3, 
        "PPN location", 
        pch = 19, 
        pt.cex = 1.2,
        col = "red",
        bty = "n")
```

* The PPN is geolocated at the following coordinates (Swedish projection RT90):  

Coordinate X (RT90): __`r as.integer(outbreak@coords[,1])`__   
Coordinate Y (RT90): __`r as.integer(outbreak@coords[,2])`__    


```{r Outbreak_WGS84, warning = FALSE, message = FALSE, echo = FALSE}

outbreak_WGS84 <- spTransform(outbreak, CRS("+init=epsg:4326"))

```

* The PPN is geolocated at the following coordinates (Coordinate Reference System WGS84):

Coordinate X (WGS84): __`r outbreak_WGS84@coords[,1]`__   
Coordinate Y (WGS84): __`r outbreak_WGS84@coords[,2]`__     

```{r Outbreak_SWEREF99, warning = FALSE, message = FALSE, echo = FALSE}

outbreak_SWEREF99 <- spTransform(outbreak_WGS84, CRS("+init=epsg:3006"))

```

* The PPN is geolocated at the following coordinates (Swedish projection SWEREF99):

Coordinate X (SWEREF99): __`r outbreak_SWEREF99@coords[,1]`__   
Coordinate Y (SWEREF99): __`r outbreak_SWEREF99@coords[,2]`__ 


```{r LeafletMap1, warning=FALSE, message=FALSE, echo = FALSE, eval=FALSE}

library(leaflet)

outbreak1 <- outbreak[,c(1,4,8,11,41)]
outbreak1 <- spTransform(outbreak1, CRS("+init=epsg:4326"))

outbreak <- leaflet(outbreak1) %>% addTiles()

outbreak %>% addCircleMarkers(color = "red")
```

****
<br>

### 2. NUMBER OF HERDS AND ANIMALS (for the investigated PPN)

```{r herds/anim_outbreak, results='asis', fig.height=4, fig.width=12, echo=FALSE}

PPN <- report_data_object()$result$PPN
outb.in.PPN <-  PPN[which(PPN$Ppn %in% outbreak@data$Ppn), ]

# temp <- outb.in.PPN
# temp <- enc2latin1(temp)
# outbreak.csv <<- write.csv2(temp, 
#                            "csv/Outbreak.csv",
#                            row.names=F)

outb.in.PPN <- outb.in.PPN[!duplicated(outb.in.PPN [c("Ppn",
                                                      "Adress",
                                                      "Typ",
                                                      "Typ.1",
                                                      "tot_anim")]),]
counts <- table(outb.in.PPN$Typ)

# Draw the graph with herds/animals count for the outbreak

par(mfrow = c(1,2), mar=c(5.1, 4.8, 4.1, 2.1), 
    mgp=c(3.8, 1, 0), las=2)

width = ifelse(length(counts) == 1, 0.2, 0.8)



b1a <- barplot(counts,
               main = "Number of herds by species", 
               ylab = "Number of herds", 
               xlim = c(0, length(counts)),
               ylim = c(0, max(counts * 1.4)),
               width = width)

text(x = b1a, y = counts, label = counts, 
     pos = 3, cex = 0.8, col = "black")

if (all(is.na(outb.in.PPN$tot_anim))) {

    counts2 <- 0

    b1b <- barplot(counts2, 
               main = "Number of animals by species", 
               xaxt = "n", 
               xlab = "", 
               ylab = "", 
               col = "white", 
               border = NA, 
               sub =  "Number of animals is NA. See Excel file for details")

} else {

    outb.in.PPN <- outb.in.PPN [!is.na(outb.in.PPN$tot_anim),]

    counts2 <-tapply(outb.in.PPN$tot_anim, 
                     INDEX = outb.in.PPN$Typ, 
                     FUN = sum)
    
    width = ifelse(length(counts2) == 1, 0.2, 0.8)

    b1b <- barplot(counts2, 
               main = "Number of animals by species",
               ylab = "Number of animals", 
               ylim = c(0, max(counts2 * 1.4)),
               xlim = c(0, length(counts2)),
               width = width)

    text(x = b1b, y = counts2, label = counts2,
         pos = 3, cex = 0.8, col = "black")
}

```

****
<br>

### 3. OWNERS INFORMATION

```{r Match_Owners, results='asis', echo=FALSE}

index <- match(PPN$Ppn, outbreak@data$Ppn)
outbreak_own <- PPN[which(PPN$Ppn == outbreak@data$Ppn), ]
n.owners <- length(unique(outbreak_own$Namn))

```

The number of owners/reference persons for the PPN under investigation is: __`r n.owners`__

```{r OwnersData, results = 'asis',echo = FALSE}

colnames(outbreak_own)[c(33, 36, 37, 31)] <- c("Adress",
                                               "Postadress",
                                               "Telefonnummer",
                                               "Typ")

kable(unique(outbreak_own[,c(32, 33, 36, 37, 38, 39, 31)]),
      align = 'c', row.names = FALSE)

```

****
<br>

### 4. VETERINARY DISTRICTS INFORMATION

The 3 most closest veterinary districts (euclidean distance) from the investigated PPN position are: 

```{r VetDistrictDist, warning=FALSE, message=FALSE, echo = FALSE, results='asis'}

district_geo_RT90 <- report_data_object()$result$district_geo_RT90

# calculate euclidean distance from outbreak to vet disctrict
dist_vet <- spDistsN1(district_geo_RT90, outbreak, longlat = FALSE)/ 1000
dist_vet <- round(dist_vet, 3)
dist_vet <- cbind(district_geo_RT90@data[ , 2:6], dist_vet)
dist_vet <- dist_vet[order(dist_vet[, 6]), ]

# show only the three most closest
kable(head(dist_vet, 3), align = 'c', digits = 1, row.names = FALSE)

```


****

<br>

### 5. RESTRICTION ZONES

This section generates 3 circular restriction zones centered at the PPN's coordinates. If PPN coordinates were missing in the dataset, the circular buffers are centred on the provided coordinates. The zones have different radius: 

* 1 km (red zone)    
* 3 km (yellow zone)    
* 10 km (green zone)    

```{r Buffers, results = 'asis', echo = FALSE, warning = TRUE, message = TRUE}

#Buffers and Outbreak: Create multiple buffers
x <- coordinates(outbreak)[, 1] # Outbreak coord x
y <- coordinates(outbreak)[, 2] # Outbreak coord y

# So far working for 1 ppn per time
stopifnot(length(x) == 1 & length(y) == 1)

# Buffer. Draw a circle with 1 km radius
nr = 500 # n. of points
r = 1000 #input$buf1 # radius
buf1 = seq(0, 2 * pi, length.out = nr)
xy = cbind(x + r * sin(buf1), y + r * cos(buf1))

# Create the spatial object
buf_sp1 = SpatialPolygons(
  list(Polygons(
  list(Polygon(xy)), "1km")))
proj4string(buf_sp1) <- CRS("+init=epsg:3021")

#  Buffer. Draw a circle with 3 km radius
nr3 = 500 # n. of points
r3 = 3000 #input$buf2  # radius
buf3 = seq(0, 2 * pi, length.out = nr3)
xz = cbind(x + r3 * sin(buf3), y + r3 * cos(buf3))

# Create a "donut" insted of a buffer. 1 km is a hole in the 3 km buffer 
buf_sp3 = SpatialPolygons(
  list(Polygons(
  list(Polygon(xz, hole = F), Polygon(xy, hole = T)), "3km")))
proj4string(buf_sp3) <- CRS("+init=epsg:3021")

# Buffer. Draw a circle with 10 km radius
nr10 = 500 # n. of points
r10 = 10000 #input$buf3  # radius
buf10 = seq(0, (2 * pi), length.out = nr10)
yz = cbind(x + r10 * sin(buf10), y + r10 * cos(buf10))

# Create a "donut" insted of a buffer. 3km is a hole in the 10km buffer
buf_sp10 = SpatialPolygons(
          list(Polygons(
          list(Polygon(yz, hole = F), Polygon(xz, hole = T)), "10km" )))
proj4string(buf_sp10) <- CRS("+init=epsg:3021")

```

